import guiChess


def обход_доски():
    координата_x = int(input('Введите координату X: '))
    координата_y = int(input('Введите координату Y: '))

    координата_xx = координата_x - 1
    координата_yy = 8 - координата_y

    ширина_доски = int(8)
    возможные_смещения_коня = [(1, 2), (-1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1)]
#    возможные_смещения_коня = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    матрица_доски = [[0 for x in range(ширина_доски)] for y in range(ширина_доски)]

    def тестовый_ход(row, col):
        return (0 <= row < ширина_доски) and (0 <= col < ширина_доски) and (матрица_доски[row][col] == 0)

    def счетчик_последующих_ходов(pos):
        хорошие_ходы = 0
        for очередной_вариант in возможные_смещения_коня:
            if тестовый_ход(pos[0] + очередной_вариант[0], pos[1] + очередной_вариант[1]):
                хорошие_ходы += 1
        return хорошие_ходы

    def найти_путь(первый_ход=(координата_yy, координата_xx, 1)):

        массив_ходов = [(первый_ход, [(первый_ход[0] + очередной_вариант_2[0], первый_ход[1] + очередной_вариант_2[1], первый_ход[2] + 1)
                                      for очередной_вариант_2 in возможные_смещения_коня if тестовый_ход(первый_ход[0] + очередной_вариант_2[0],
                                                                                                         первый_ход[1] + очередной_вариант_2[1])])]
        матрица_доски[первый_ход[0]][первый_ход[1]] = первый_ход[2]

        while len(массив_ходов) > 0:
            топ_ходы = массив_ходов[-1][1]
            if len(топ_ходы) == 0:
                последний_ход = массив_ходов[-1][0]
                матрица_доски[последний_ход[0]][последний_ход[1]] = 0
                массив_ходов.pop()
            else:
                последний_ход = топ_ходы.pop()
                матрица_доски[последний_ход[0]][последний_ход[1]] = последний_ход[2]
                if последний_ход[2] == (ширина_доски * ширина_доски):
                    return True
                следующий_шаги = [(последний_ход[0] + очередной_вариант_3[0], последний_ход[1] + очередной_вариант_3[1], последний_ход[2] + 1)
                                  for очередной_вариант_3 in возможные_смещения_коня if тестовый_ход(последний_ход[0] + очередной_вариант_3[0],
                                                                                                     последний_ход[1] + очередной_вариант_3[1])]
                if len(следующий_шаги) == 0:
                    матрица_доски[последний_ход[0]][последний_ход[1]] = 0
                else:
                    следующий_шаги.sort(key=счетчик_последующих_ходов, reverse=True)
                    массив_ходов.append((последний_ход, следующий_шаги))
        return False

    найти_путь()

    mass={}
    p = None
    for i in range(8):
        for j in range(8):
            p = матрица_доски[i][j]
            x = (i, j)
            mass[p] = x

    hodu = [(0, 0)]*64
    for key in mass:
        hodu[key-1]=mass[key]
    m = 0

    hodu1 = [(0, 0)]*64
    a = 0
    for i in (hodu):
        y, x = i
        x, y = x + 1, 8 - y
        hodu1[a] = (x, y)
        a += 1
    return hodu1


if __name__ == '__main__':
    guiChess.инициализация_интерфейса()
    hodu1 = обход_доски()
    guiChess.перемести_фигуру__по_доске(hodu1)

    guiChess.окно.mainloop()






